# 数据结构

## 1、栈

### 1.1 栈的概述

栈(stack)，它是一种受限的线性质，后进先出（LIFO）

* 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底

  <img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/8eb4b62c-9470-420d-93cf-97ebd25dcfe3.png" style="zoom:50%;" />

### 1.2 栈的常规操作

| 方法       | 作用                                             |
| ---------- | ------------------------------------------------ |
| push(e)    | 添加一个新元素到栈顶                             |
| pop()      | 移除栈顶元素，同时返回被移除的元素               |
| peek()     | 返回栈顶元素，不对栈做任何的修改                 |
| isEmpty()  | 如果栈里没有任何元素就返回true，否则返回false    |
| size()     | 返回栈里的元素个数。这个方法和数组的length很类似 |
| toString() | 将栈结构的内容以字符串形式返回                   |

### 1.3 用js模拟栈

```javascript
function Stack(){
	this.stack = []
}
Stack.prototype.push=function(element) {
	this.stack.push(element)
}
Stack.prototype.pop=function(){
	return this.stack.pop()
}
Stack.prototype.size=function(){
	return this.stack.length
}
Stack.prototype.peek=function(){
	return this.stack[this.size()-1]
}
Stack.prototype.isEmpty=function() {
	return this.size === 0 ? true : false
}
Stack.prototype.toString=function(){
	return this.stack.join(' ')
}
```

### 1.4 栈的应用

[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)、[队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)、[最小栈](https://leetcode-cn.com/problems/min-stack/)



## 2、队列

### 2.1 队列的概述

队列(queue)，它是一种受限的线性质，先进先出（LIFO）

* 其限制是仅允许在表的前端进行删除操作，在表的后端进行插入操作

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/48763ff5-30d2-4041-bede-035114bbf4cc.png" style="zoom: 67%;" />

### 2.2 队列的常规操作

| 方法       | 作用                                               |
| ---------- | -------------------------------------------------- |
| enqueue(e) | 向队列尾部添加一个或多个新的元素                   |
| dequeue()  | 移除队列第一个元素，同时返回被移除的元素           |
| front()    | 返回队列第一个元素，不对队列任何的修改             |
| isEmpty()  | 如果队列里没有任何元素就返回true，否则返回false    |
| size()     | 返回队列里的元素个数。这个方法和数组的length很类似 |
| toString() | 将队列的内容以字符串形式返回                       |

### 2.3 用js模拟队列

```javascript
function Queue(){
    this.queue = []
}
Queue.prototype.enqueue = function(ele){
    this.queue.push(ele)
} 
Queue.prototype.dequeue = function(){
    return this.queue.shift()
} 
Queue.prototype.front = function(){
    return this.queue[this.size() -1]
} 
Queue.prototype.size = function(){
    return this.queue.length
} 
Queue.prototype.front = function(){
    return this.size === 0 
} 
Queue.prototype.toString = function(){
    return this.queue.join('') 
} 
```

### 2.4 队列的应用

[设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)、[设计双端队列](https://leetcode-cn.com/problems/design-circular-deque/)、[最近请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)



## 3、链表

### 3.1链表的概述

链表 [Linked List]：链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。

<img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/55dded18-0276-4b89-96ae-7f8a6b925b83.png" style="zoom:50%;" />

### 3.2 链表的常规操作

| 方法              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| append(ele)       | 向链表尾部添加一个元素                                       |
| insert(index,ele) | 向链表的特定位置插入一个新的项                               |
| get(index)        | 获取对应位置的元素                                           |
| indexOf(ele)      | 返回元素在链表的第一个匹配元素的索引，如果没有则返回-1       |
| update(index)     | 修改某个位置的元素                                           |
| removeAt(index)   | 从链表的特定位置移除当前元素                                 |
| remove(ele)       | 从链表种移除该元素                                           |
| isEmpty()         | 如果链表没有任何元素，返回true，否则返回false                |
| size()            | 返回链表包含的元素个数。与数组的length属性类似               |
| toString()        | 由于链表使用了Node类，需要重写toString()方法，让其只输出元素的值 |

### 3.3 用js模拟链表

```javascript
function LinkedList (){
    //链表头
    this.head = null
    this.length = 0
}
 // 创建链表节点
function Node(data){
    this.data = data
    this.next = null
}
LinkedList.prototype.append = function(data){
    let newNode = new Node(data)
    if(this.length === 0){
        this.head = newNode
    }else{
        let currentNode = this.head
        while(currentNode.next){
            currentNode = currentNode.next
        }
        currentNode.next = newNode
    }
    this.length += 1
}
LinkedList.prototype.insert = function(index, data){
    let newNode = new Node(data)
    if(index < 0 || index > this.length) return false
    //插入的节点为第一个
    if(index === 0){
        newNode.next = this.head
        this.head = newNode
    }else{
        let currentNode = this.head,
        curIndex = 0,
        previous = null
        while(curIndex ++ <  index){
            previous = currentNode
            currentNode = currentNode.next
        }
        newNode.next = currentNode
        previous.next = newNode
    }
    this.length ++ 
    return true
}
LinkedList.prototype.get = function(index){
    if(index < 0 || index > this.length) return null
    let curNode = this.head,
        curIndex = 0 
    while(curIndex++ < index){
        curNode = curNode.next
    }
    return curNode.data
}
LinkedList.prototype.indexOf = function(item){
    let curNode = this.head,
        curIndex = 0
    while(curNode){
        curNode = curNode.next
        if(curNode && curNode.data == item){
            return curIndex
        }
    }
    return -1
}
LinkedList.prototype.update = function(index, item){
    if(index < 0 || index > this.length) return false
    let curNode = this.head,
        curIndex = 0
    while(curIndex++ < index){
        curNode = curNode.next
    }
    curNode.data = item
}
LinkedList.prototype.removeAt = function(index){
    if(index < 0 || index > this.length) return null
    if(index === 0){
        this.head = null
    }else{
        let curNode = this.head,
        previous = null,
        curIndex = 0

    while(curIndex++ < index){
        previous = curNode
        curNode = curNode.next
    }
    previous.next = curNode.next
    }
    this.length --
}
LinkedList.prototype.remove = function(data){
    let index = this.indexOf(data)
    this.removeAt(index)
}
LinkedList.prototype.isEmpty = function(){
    return this.length > 0 ?  true : false
}
LinkedList.prototype.toString = function() {
    let res = '',
    currentNode = this.head
    while(currentNode){
        res += currentNode.data
        currentNode = currentNode.next 
    }
    return res
}
```

### 3.4 链表的应用

[两数相加](https://leetcode-cn.com/problems/add-two-numbers/)、[合并k个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)、[旋转链表](https://leetcode-cn.com/problems/rotate-list/)、[分离链表](https://leetcode-cn.com/problems/partition-list/)



## 4、集合

### 4.1 集合的概述

集合通常是由一组无序、不能重复的元素构成。不能通过下标进行访问

### 4.2 集合的常规操作

| 方法          | 作用                                             |
| ------------- | ------------------------------------------------ |
| add(value)    | 向集合添加一个元素                               |
| remove(value) | 从集合移除一个元素                               |
| has(value)    | 如果在集合中，返回true，否则返回false            |
| clear()       | 移除集合中的所有项                               |
| size()        | 返回集合所包含元素的数量，与数组的length属性类似 |
| values()      | 返回一个包含集合所有值的数组                     |

### 4.3 用js模拟集合

```javascript
function Set(){
    this.items = {}
}
Set.prototype.add = function(value){
    if(this.has(value)) return false
    this.items[value] = value
    return true
}
Set.prototype.has = function(value){
    return this.items.hasOwnProperty(value)
}
Set.prototype.remove = function(value){
    if(!this.has(value)) return false
    delete this.items[value]
    return true
}
Set.prototype.clear = function(){
    this.items = {}
}
Set.prototype.size = function(){
    return Object.keys(this.items).length
}
Set.prototype.values = function(){
    return Object.keys(this.items)
}
```

### 4.4 集合的应用

[删除数组中重复的元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)、[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate-ii/)、[两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

