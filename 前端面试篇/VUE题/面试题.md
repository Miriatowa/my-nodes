# 面试题-VUE篇

## 1、说说你对SPA单页面应用的理解，他的优缺点是什么？

SPA仅在web页面初始化时加载相应的HTML、JS、CSS。一旦页面加载完成，不会随用户的操作重新加载页面或者跳转。取而代之的是利用路由机制实现HTML内容的更换，UI与用户的交互，避免页面的重载。

#### 优点：

* 用户体验好、快，内容的改变不需要重载页面，避免了不必要的重复渲染
* 基于上面一点，SPA相对服务器压力小点
* 前后端职责分离，架构清晰。

#### 缺点：

* 首次加载耗时多：为实现单页web应用功能及现实效果，需要在加载页面的时候将js、css统一加载，部分页面按需加载
* SEO难度较大：所有的内容都在一个页面中动态替换显示，不利于SEO
* 前进后退路由管理：单页应用在一个页面中显示所有，不能使用浏览器的前进后退功能，所有的页面切换需要自己手动实现



## 2、v-show和v-if有什么区别？切换时会触发哪些生命周期？

#### v-if

真正的条件渲染，因为它会确保在切换过程中条件块内事件监听器和子组件适当地被销毁和重建，惰性渲染。

##### 初始渲染：

初始值为 **false** 组件**不会**渲染，生命周期钩子**不会**执行
初始值为 **true** 时，组件会进行渲染，并依次执行 ：

1. beforeCreate 
2. created
3. beforeMount
4. mounted 

##### 切换：

false  =>  true
依次执行 beforeCreate,created,beforeMount,mounted 生命周期。
true => false
依次执行 beforeDestroy,destroyed 生命周期。

#### v-show

> 不管初始条件是什么，元素都会被渲染，并且只是简单地基于CSS的‘**dispaly**’属性进行切换。

##### 初始渲染：

无论初始状态，组件都会渲染，**v-show** 的渲染是**非惰性**的，依次执行

1. beforeCreate
2. created
3. beforeMount
4. mounted 

##### 切换

对生命周期钩子无影响，切换时组件始终保持在 mounted 钩子。

## 3、说说你对MVVM的理解？

MVVM（Model - View - ViewModel）是一个软件架构设计模式，源于经典的MVC（Modle-View-Controller）模式，MVVM促进了前后端分离，极大的提高了前端的开发效率，核心是ViewModel，他就像一个中转站，负责转换Model中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Modle层通过接口请求进行数据交互，如图

![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/332a2ab3-117a-41d9-8469-93dea4a27856.jpg)

#### view层

VIew是视图层，前端主要由HTML和CSS构建

#### Modle层

MOdel是数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的API接口

#### ViewModle层

ViewModel是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。

## 4、怎么理解vue的单向数据流？

所有的prop都使其父子prop之间形成一个单向下行绑定：**父级prop的更新会向下流动到子组件中，但是反向不行**。这样会防止子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解。

#### 常见的改变prop情形：

1. prop用来传递初始值；这个子组件接下来希望将其作为一个本地的prop数据来使用。

   ```javascript
   props:['initNum']
   data: () =>{
       return {
           num: this.props.initNum
       }
   }
   ```

2. 这个prop以一种原始值传入但需要进行转换。在这种情况下，最好使用这个prop的值来定义一个计算属性

   ```javascript
   props:['initNum']
   computed: {
       addNum: ()=>{
           return this.props.initNum++
       }
       
   }
   ```

## 5、谈谈你对vue生命周期的理解？

#### 什么是生命周期？

vue实例从创建、初始化数据、编译模板、挂载DOM => 渲染DOM、更新DOM=>渲染DOM、卸载等一系列过程，称之为vue的生命周期

#### 各个生命周期作用

| 生命周期      | 描述                                                         |
| :------------ | ------------------------------------------------------------ |
| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                       |
| created       | 组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用 |
| beforeMount   | 在挂载开始之前调用，相关的render函数首次调用                 |
| mounted       | el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子       |
| beforeUpdate  | 组件数据更新之前调用，发生在虚拟dom打补丁之前                |
| update        | 组件数据更新之后                                             |
| activited     | keep-alive专属，组件被激活时调用                             |
| deactivated   | kepp-alive专属，组件被销毁时调用                             |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |

#### 生命周期示意图

![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f8040833-b067-4f14-836a-a9837f7dab99/6308bce9-40cf-48c6-b5e7-abfd276e5ae4.png)

## 6、computed和watch的区别和运用场景？

#### computed

计算属性，依赖其它属性值，并且computed的值有缓存。只有在他依赖的属性值发生改变时，下一次获取computed的值才会重新计算computed的值

#### watch

更多的时“观察”作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调执行后续操作

#### 适用场景

* 当需要进行数值计算，并且依赖于其他数据时，使用computed，利用其缓存特性，避免每次获取值时，都重新计算
* 当我们需要在数据变化时执行异步或者开销较大的操作时，应该使用watch，使用watch允许我们执行异步操作