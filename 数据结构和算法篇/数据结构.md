# 数据结构

## 1、栈

### 1.1 栈的概述

栈(stack)，它是一种受限的线性质，后进先出（LIFO）

* 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底

  <img src="C:\Users\余洵杰\AppData\Roaming\Typora\typora-user-images\image-20210612103926592.png" alt="栈" style="zoom:50%;" />

### 1.2 栈的常规操作

| 方法       | 作用                                             |
| ---------- | ------------------------------------------------ |
| push(e)    | 添加一个新元素到栈顶                             |
| pop()      | 移除栈顶元素，同时返回被移除的元素               |
| peek()     | 返回栈顶元素，不对栈做任何的修改                 |
| isEmpty()  | 如果栈里没有任何元素就返回true，否则返回false    |
| size()     | 返回栈里的元素个数。这个方法和数组的length很类似 |
| toString() | 将栈结构的内容以字符串形式返回                   |

### 1.3 用js模拟栈

```javascript
function Stack(){
	this.stack = []
}
Stack.prototype.push=function(element) {
	this.stack.push(element)
}
Stack.prototype.pop=function(){
	return this.stack.pop()
}
Stack.prototype.size=function(){
	return this.stack.length
}
Stack.prototype.peek=function(){
	return this.stack[this.size()-1]
}
Stack.prototype.isEmpty=function() {
	return this.size === 0 ? true : false
}
Stack.prototype.toString=function(){
	return this.stack.join(' ')
}
```

### 1.4 栈的应用

[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)、[队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)、[最小栈](https://leetcode-cn.com/problems/min-stack/)



## 2、队列

### 2.1 队列的概述

队列(queue)，它是一种受限的线性质，先进先出（LIFO）

* 其限制是仅允许在表的前端进行删除操作，在表的后端进行插入操作

<img src="C:\Users\余洵杰\AppData\Roaming\Typora\typora-user-images\image-20210612104528256.png" alt="image-20210612104528256" style="zoom:67%;" />

### 2.2 队列的常规操作

| 方法       | 作用                                               |
| ---------- | -------------------------------------------------- |
| enqueue(e) | 向队列尾部添加一个或多个新的元素                   |
| dequeue()  | 移除队列第一个元素，同时返回被移除的元素           |
| front()    | 返回队列第一个元素，不对队列任何的修改             |
| isEmpty()  | 如果队列里没有任何元素就返回true，否则返回false    |
| size()     | 返回队列里的元素个数。这个方法和数组的length很类似 |
| toString() | 将队列的内容以字符串形式返回                       |

### 2.3 用js模拟队列

```javascript
function Queue(){
    this.queue = []
}
Queue.prototype.enqueue = function(ele){
    this.queue.push(ele)
} 
Queue.prototype.dequeue = function(){
    return this.queue.shift()
} 
Queue.prototype.front = function(){
    return this.queue[this.size() -1]
} 
Queue.prototype.size = function(){
    return this.queue.length
} 
Queue.prototype.front = function(){
    return this.size === 0 
} 
Queue.prototype.toString = function(){
    return this.queue.join('') 
} 
```

### 2.4 队列的应用

[设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)、[设计双端队列](https://leetcode-cn.com/problems/design-circular-deque/)、[最近请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)



## 3、链表

### 3.1链表的概述

链表 [Linked List]：链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。

<img src="C:\Users\余洵杰\AppData\Roaming\Typora\typora-user-images\image-20210613130329686.png" style="zoom:50%;" />

### 3.2 链表的常规操作

| 方法              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| append(ele)       | 向链表尾部添加一个元素                                       |
| insert(index,ele) | 向链表的特定位置插入一个新的项                               |
| get(index)        | 获取对应位置的元素                                           |
| indexOf(ele)      | 返回元素在链表的第一个匹配元素的索引，如果没有则返回-1       |
| update(index)     | 修改某个位置的元素                                           |
| removeAt(index)   | 从链表的特定位置移除当前元素                                 |
| remove(ele)       | 从链表种移除该元素                                           |
| isEmpty()         | 如果链表没有任何元素，返回true，否则返回false                |
| size()            | 返回链表包含的元素个数。与数组的length属性类似               |
| toString()        | 由于链表使用了Node类，需要重写toString()方法，让其只输出元素的值 |

### 3.3 用js模拟链表

```javascript
function LinkedList (){
    //链表头
    this.head = null
    this.length = 0
}
 // 创建链表节点
function Node(data){
    this.data = data
    this.next = null
}
LinkedList.prototype.append = function(data){
    let newNode = new Node(data)
    if(this.length === 0){
        this.head = newNode
    }else{
        let currentNode = this.head
        while(currentNode.next){
            currentNode = currentNode.next
        }
        currentNode.next = newNode
    }
    this.length += 1
}
LinkedList.prototype.insert = function(index, data){
    let newNode = new Node(data)
    if(index < 0 || index > this.length) return false
    //插入的节点为第一个
    if(index === 0){
        newNode.next = this.head
        this.head = newNode
    }else{
        let currentNode = this.head,
        curIndex = 0,
        previous = null
        while(curIndex ++ <  index){
            previous = currentNode
            currentNode = currentNode.next
        }
        newNode.next = currentNode
        previous.next = newNode
    }
    this.length ++ 
    return true
}
LinkedList.prototype.get = function(index){
    if(index < 0 || index > this.length) return null
    let curNode = this.head,
        curIndex = 0 
    while(curIndex++ < index){
        curNode = curNode.next
    }
    return curNode.data
}
LinkedList.prototype.indexOf = function(item){
    let curNode = this.head,
        curIndex = 0
    while(curNode){
        curNode = curNode.next
        if(curNode && curNode.data == item){
            return curIndex
        }
    }
    return -1
}
LinkedList.prototype.update = function(index, item){
    if(index < 0 || index > this.length) return false
    let curNode = this.head,
        curIndex = 0
    while(curIndex++ < index){
        curNode = curNode.next
    }
    curNode.data = item
}
LinkedList.prototype.removeAt = function(index){
    if(index < 0 || index > this.length) return null
    if(index === 0){
        this.head = null
    }else{
        let curNode = this.head,
        previous = null,
        curIndex = 0

    while(curIndex++ < index){
        previous = curNode
        curNode = curNode.next
    }
    previous.next = curNode.next
    }
    this.length --
}
LinkedList.prototype.remove = function(data){
    let index = this.indexOf(data)
    this.removeAt(index)
}
LinkedList.prototype.isEmpty = function(){
    return this.length > 0 ?  true : false
}
LinkedList.prototype.toString = function() {
    let res = '',
    currentNode = this.head
    while(currentNode){
        res += currentNode.data
        currentNode = currentNode.next 
    }
    return res
}
```

### 3.4 链表的应用

[两数相加](https://leetcode-cn.com/problems/add-two-numbers/)、[合并k个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)、[旋转链表](https://leetcode-cn.com/problems/rotate-list/)、[分离链表](https://leetcode-cn.com/problems/partition-list/)
